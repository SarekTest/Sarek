package dev.sarek.agent.constructor_mock;

import java.util.Collections;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Set;

/**
 * The constructor mock registry keeps track of a set of target class names registered to be targets for constructor
 * mocking. Constructor mocking as such only works if the corresponding target class and its super classes have been
 * transformed by {@link ConstructorMockTransformer}.
 */
public class ConstructorMockRegistry {
  // TODO: Maybe use Set<Class<?>> instead because with strings we cannot differentiate class cloaders. But then we need
  //       to modify isMockUnderConstruction() and the generated constructor code to pass on the calling class.
  //       Alternatively, if one day we drop Java 8 support we can use the StackWalker API.
  private static Set<String> mockClasses = new HashSet<>();

  // This is effectively an IdentityHashSet, see https://stackoverflow.com/a/48096408/1082681
  private static Set<Object> mockInstances = Collections.newSetFromMap(new IdentityHashMap<>());

  /**
   * Determine whether a given class has been registered for constructor mocking
   *
   * @param className class for which to find out constructor mocking state
   * @return constructor mocking state for given class
   */
  public static boolean isMock(String className) {
    return mockClasses.contains(className);
  }

  /**
   * Register a class as a constructor mocking target. Of course, constructor mocking as such only works if the
   * corresponding class has been transformed by {@link ConstructorMockTransformer}.
   *
   * @param className class to be registered as a constructor mocking target
   * @return result according to {@link Set#add(Object)}
   */
  public static boolean activate(String className) {
    return mockClasses.add(className);
  }

  /**
   * Unregister a class as a constructor mocking target.
   *
   * @param className class to be unregistered as a constructor mocking target
   * @return result according to {@link Set#remove(Object)}
   */
  public static boolean deactivate(String className) {
    return mockClasses.remove(className);
  }

  /**
   * This method is not meant to be called directly by Sarek users. It is used internally and called by constructor
   * instrumentation code generated by {@link ConstructorMockTransformer} in order to find out whether to bypass normal
   * constructor execution (constructor mocking active) or not (constructor mocking inactive) for the object under
   * construction.
   * <p></p>
   * <i>API note: This method must be public because otherwise it cannot be called by constructors in other
   * packages.</i>
   *
   * @return boolean value specifying if the object under construction ought to be a mock or not
   */
  public static int isMockUnderConstruction() {
    // TODO:
    //   - Under Java 8, according to Rafael Winterhalter it would be quicker and more efficient (as in not
    //     materialising the whole stack) to use sun.misc.JavaLangAccess, e.g.
    //       sun.misc.SharedSecrets.getJavaLangAccess().getStackTraceElement(new Throwable(), 2)
    //   - Java 9+ has the Stack Walking API (https://www.baeldung.com/java-9-stackwalking-api).
    //   - In oder to dynamically switch between the two, look into method handles for dispatching to the appropriate
    //     API (https://www.baeldung.com/java-method-handles).

    // This is said to be faster than Thread.currentThread().getStackTrace()
    StackTraceElement[] stackTrace = new Throwable().getStackTrace();
    int constructorIndex = -1;
    for (int i = 1; i < stackTrace.length; i++) {
      if (!stackTrace[i].getMethodName().equals("<init>"))
        break;
      constructorIndex = i;
    }
    return constructorIndex > 0 && isMock(stackTrace[constructorIndex].getClassName())
      ? constructorIndex
      : -1;
  }

  public static void registerMockInstance(Object mockInstance) {
    // Caveat: Do not log anything here, especially not mock objects with possibly stubbed toString methods. Otherwise
    // you might see strange exceptions in then failing tests.
    mockInstances.add(mockInstance);
    // TODO:
    //   - add 'unregister' method
    //   - automatic unregistration if mock class is deactivated
    //   - group instances by class or class name -> turn mockInstances Set into a Map
    //   - make registration optional (default: off) via fluent mock API
  }
}
